#!/usr/bin/env python3
"""
scalar_energy_scaling_and_plot.py

Goal:
    Make a *single figure* comparing defrag energy scaling:

      - Ising + defrag   →  E_defrag_total(L)  ~ L^4  (super-extensive)
      - Scalar + defrag  →  E_defrag(L)        ~ L^2  (extensive)

What this script does:

  1. Loads Ising energy scaling results from:
        energy_scaling_analysis/energy_scaling_results.csv
     (generated by investigate_energy_scaling.py).

  2. Runs the scalar-field defrag simulator for several L values,
     measures the final E_defrag for each L, and builds an in-memory
     table of (L, E_defrag).

  3. Produces a log–log plot of |E_defrag| vs L, fits a power law
     E ~ L^p for each, prints the exponents, and saves:

        energy_scaling_comparison.png
"""

import argparse
from pathlib import Path

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Import your scalar simulator
from scalar_field_defrag_gpu import ScalarFieldDefragGPU


# ---------------------------------------------------------------------
# Power-law fitting
# ---------------------------------------------------------------------

def fit_power_law(L: np.ndarray, E: np.ndarray):
    """
    Fit |E| ~ a * L^p using linear regression in log10 space.

    Returns:
        p  : exponent
        a  : prefactor
    """
    L = np.asarray(L, dtype=float)
    E = np.asarray(E, dtype=float)

    mask = (L > 0) & (E != 0)
    L = L[mask]
    E = E[mask]

    logL = np.log10(L)
    logE = np.log10(np.abs(E))

    p, loga = np.polyfit(logL, logE, 1)
    a = 10.0 ** loga
    return p, a


# ---------------------------------------------------------------------
# Scalar field sweep
# ---------------------------------------------------------------------

def run_scalar_sweep(
    L_values,
    dx=1.0,
    dt=0.005,
    g_defrag=0.5,
    v=1.0,
    lambda_param=0.5,
    n_steps=1000,
    snapshot_interval=100,
    init_mean=1.0,
    init_noise_amp=0.1,
    init_seed=42,
    output_root="scalar_energy_scaling_runs",
):
    """
    For each L in L_values:
      - set up ScalarFieldDefragGPU
      - start from uniform + noise
      - evolve for n_steps
      - record final E_defrag

    Returns:
        DataFrame with columns: L, E_defrag_total
    """
    results = []

    output_root = Path(output_root)
    output_root.mkdir(exist_ok=True)

    for L in L_values:
        print("\n" + "=" * 70)
        print(f"[SCALAR SWEEP] L = {L}")
        print("=" * 70)

        out_dir = output_root / f"L{L}"
        out_dir.mkdir(parents=True, exist_ok=True)

        sim = ScalarFieldDefragGPU(
            L=L,
            dx=dx,
            dt=dt,
            g_defrag=g_defrag,
            v=v,
            lambda_param=lambda_param,
        )

        psi_init = sim.create_uniform_noise(
            mean=init_mean,
            noise_amp=init_noise_amp,
            seed=init_seed,
        )

        psi = psi_init.copy()
        final_E_defrag = None

        for step in range(n_steps + 1):
            # Only need diagnostics occasionally
            if step % snapshot_interval == 0 or step == n_steps:
                Phi = sim.solve_defrag_potential(psi)
                diag = sim.compute_diagnostics(psi, Phi)
                final_E_defrag = diag["E_defrag"]
                print(
                    f"[L={L:3d} STEP={step:5d}] "
                    f"E_defrag={final_E_defrag:+.4e}, "
                    f"max_rho={diag['max_rho']:.4f}"
                )

            if step < n_steps:
                psi, _ = sim.evolve_step_rk4(psi)

        if final_E_defrag is None:
            raise RuntimeError(
                f"No E_defrag recorded for L={L}. "
                f"Check n_steps/snapshot_interval."
            )

        results.append({"L": L, "E_defrag_total": final_E_defrag})

    df_scalar = pd.DataFrame(results)
    return df_scalar


# ---------------------------------------------------------------------
# Plotting
# ---------------------------------------------------------------------

def make_comparison_plot(df_ising: pd.DataFrame,
                         df_scalar: pd.DataFrame,
                         output_path: Path):
    """
    Make the log–log comparison figure and save to output_path.
    """
    L_ising = df_ising["L"].to_numpy(dtype=float)
    E_ising = df_ising["E_defrag_total"].to_numpy(dtype=float)

    L_scalar = df_scalar["L"].to_numpy(dtype=float)
    E_scalar = df_scalar["E_defrag_total"].to_numpy(dtype=float)

    # Fit power laws
    p_ising, a_ising = fit_power_law(L_ising, E_ising)
    p_scalar, a_scalar = fit_power_law(L_scalar, E_scalar)

    print("\n=== ENERGY SCALING FITS ===")
    print(f"Ising + defrag : |E| ≈ {a_ising:.3e} * L^{p_ising:.3f}")
    print(f"Scalar + defrag: |E| ≈ {a_scalar:.3e} * L^{p_scalar:.3f}")

    # Log–log figure
    fig, ax = plt.subplots(figsize=(7, 5))

    ax.loglog(
        L_ising,
        np.abs(E_ising),
        "o",
        label=f"Ising (p≈{p_ising:.2f})",
    )
    ax.loglog(
        L_scalar,
        np.abs(E_scalar),
        "s",
        label=f"Scalar field (p≈{p_scalar:.2f})",
    )

    # Smooth lines for the fits
    L_min = min(L_ising.min(), L_scalar.min())
    L_max = max(L_ising.max(), L_scalar.max())
    L_fit = np.linspace(L_min, L_max, 200)

    ax.loglog(
        L_fit,
        a_ising * L_fit**p_ising,
        "--",
        alpha=0.7,
    )
    ax.loglog(
        L_fit,
        a_scalar * L_fit**p_scalar,
        "--",
        alpha=0.7,
    )

    ax.set_xlabel("L")
    ax.set_ylabel(r"$|E_{\mathrm{defrag}}|$")
    ax.set_title("Energy Scaling: Ising vs Scalar (defrag coupling)")
    ax.grid(True, which="both", alpha=0.3)
    ax.legend()

    plt.tight_layout()
    plt.savefig(output_path, dpi=200)
    plt.close()
    print(f"\nSaved comparison figure to {output_path}")


# ---------------------------------------------------------------------
# Main CLI
# ---------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(
        description=(
            "Compare defrag energy scaling: "
            "Ising (L^4) vs scalar field (L^2)."
        ),
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "--ising_csv",
        type=str,
        default="energy_scaling_analysis/energy_scaling_results.csv",
        help="Ising energy-scaling CSV from investigate_energy_scaling.py",
    )
    parser.add_argument(
        "--L_values",
        type=int,
        nargs="+",
        default=[32, 48, 64, 96],
        help="L values to sweep for scalar field.",
    )
    parser.add_argument(
        "--n_steps",
        type=int,
        default=1000,
        help="Number of time steps for each scalar run.",
    )
    parser.add_argument(
        "--snapshot_interval",
        type=int,
        default=100,
        help="How often to measure E_defrag in scalar runs.",
    )
    parser.add_argument(
        "--output",
        type=str,
        default="energy_scaling_comparison.png",
        help="Output figure filename.",
    )
    args = parser.parse_args()

    ising_path = Path(args.ising_csv)
    if not ising_path.exists():
        raise FileNotFoundError(
            f"Ising CSV not found at {ising_path}. "
            f"Run `python investigate_energy_scaling.py` first."
        )

    # 1) Load Ising results
    df_ising = pd.read_csv(ising_path)
    if "L" not in df_ising.columns or "E_defrag_total" not in df_ising.columns:
        raise ValueError(
            f"{ising_path} must have columns 'L' and 'E_defrag_total'. "
            f"Found columns: {list(df_ising.columns)}"
        )

    # 2) Run scalar sweep
    df_scalar = run_scalar_sweep(
        L_values=args.L_values,
        n_steps=args.n_steps,
        snapshot_interval=args.snapshot_interval,
    )

    # Save scalar results as a convenience
    scalar_csv = Path("scalar_energy_scaling_results.csv")
    df_scalar.to_csv(scalar_csv, index=False)
    print(f"\nSaved scalar energy scaling results to {scalar_csv}")

    # 3) Make comparison figure
    out_path = Path(args.output)
    make_comparison_plot(df_ising, df_scalar, out_path)


if __name__ == "__main__":
    main()
